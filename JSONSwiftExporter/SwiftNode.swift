//
//  SwiftClass.swift
//  JSONSwiftExporter
//
//  Created by Jonathan French on 26.02.23.
//

import Foundation
import SwiftUI

enum SwiftType: String, Decodable, CaseIterable, Identifiable {
    var id: SwiftType { self }
    
    case String,Int,Double,Date,Url,Bool,Array,Struct
    
    var simpleDescription: String {
        switch self {
        case .String: return "String"
        case .Int: return "Int"
        case .Double: return "Double"
        case .Date: return "Date"
        case .Url: return "URL"
        case .Bool: return "Bool"
        case .Array: return "Array"
        case .Struct: return "Struct"
        }
    }
}

class SwiftNode:ObservableObject, Identifiable {
    let id = UUID()
    @Published var nodeName: String = ""
    @Published var properties: [SwiftNodeProperties] = []
    @Published var isPublic = true
    @Published var isArray = false
    @Published var generateTest = true
    @Published var snakeCase = false

    fileprivate func swiftHeader(_ swiftString: inout String) {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "MMM dd, yyyy"
        let todaysDate = dateFormatter.string(from: Date())
        swiftString += "//" + "\n"
        swiftString += "// \(nodeName).swift" + "\n"
        swiftString += "//" + "\n"
        swiftString += "// Generated by JSONSwiftExporter on \(todaysDate)" + "\n"
        swiftString += "//" + "\n\n"
        swiftString += "import Foundation" + "\n\n"
    }
    
    fileprivate func swiftDec(prop: SwiftNodeProperties) -> String {
        if prop.propertyType == .Array {
            return "\("[" + prop.childNode!.nodeName + "]")"
        }
        else if prop.propertyType == .Struct {
            return "\(prop.childNode!.nodeName)"
        } else {
            return "\(prop.propertyType.simpleDescription)"
        }
    }
    
    fileprivate func swiftStruct(_ swiftString: inout String, props: [SwiftNodeProperties]) {
        swiftString += "\(isPublic ? "public " : "")struct \(nodeName): Codable {" + "\n\n"
        props.forEach {
            swiftString += "\tpublic \($0.isVar ? "var" : "let") \($0.hasCodingKey ? $0.codingKey : $0.propertyName): \(swiftDec(prop: $0))\($0.isOptional ? "?" : "") " + "\n"
        }
        ///If any of our properties has a coding key then add them to struct.
        if properties.contains(where: {$0.hasCodingKey == true }) {
            swiftCodingKeys(&swiftString)
        }
        swiftString += "}" + "\n\n"
        ///If any node has a child node then add them.
        props.forEach {
            if let child = $0.childNode {
                child.swiftStruct(&swiftString,props: child.properties)
            }
        }
    }
    
    fileprivate func swiftCodingKeys(_ swiftString: inout String) {
        swiftString += "\n\tenum CodingKeys: String, CodingKey {" + "\n"
        swiftString += "\tcase " //+ "\n\t"
        properties.forEach {
            swiftString += "\($0.hasCodingKey ? "" : $0.propertyName + ",") "
        }
        swiftString.removeLast(2)
        swiftString += "\t\n"
            properties.forEach {
                if $0.hasCodingKey {
                    swiftString += "\tcase \($0.propertyName) = \"\($0.codingKey)\" \n"
                }
            }
            swiftString += "\t}" + "\n"
    }
    
    func generateSwiftCode() -> String {
        var swiftString = ""
        swiftHeader(&swiftString)
        swiftStruct(&swiftString,props: properties)
        /// Add in test or code to process the json into the structure.
        if (generateTest) {
            swiftString += generateTestCode()
        }
         return swiftString
    }
    
    func generateTestCode() -> String {
        let nodes = isArray ? "[\(nodeName)]" : "\(nodeName)"
        let snakes = snakeCase ? "decoder.keyDecodingStrategy = .convertFromSnakeCase" : ""
        let testString = """

    /// Probably want to move this somewhere else and add in some more code!

    public struct fetchRequests {
        public init() {
        }
    }

    /// As here we add an extension to the above for the \(nodeName) processing
    \n\nextension fetchRequests {

        public func fetch\(nodeName)(jsonString: String) -> \(nodes) {
            let decoder = JSONDecoder()
            let jsonData = jsonString.data(using: .utf8)!
            \(snakes)
            let parseJson: \(nodes) = try! decoder.decode(\(nodes).self, from: jsonData)
            return parseJson
        }
    }\n\n
"""
        
        return testString
    }
}

class SwiftNodeProperties:ObservableObject, Identifiable {
    let id = UUID()
    @Published var propertyName: String = ""
    @Published var propertyType: SwiftType = .String
    @Published var isOptional: Bool = false
    @Published var isVar: Bool = false
    @Published var hasCodingKey: Bool = false
    @Published var codingKey: String = ""
    @Published var dateFormat: String = ""
    @Published var childNode: SwiftNode?
}

extension String {
    func capitalizingFirstLetter() -> String {
      return prefix(1).uppercased() + self.lowercased().dropFirst()
    }

    mutating func capitalizeFirstLetter() {
      self = self.capitalizingFirstLetter()
    }
}
